[공식문서](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/accesscontrol/)

# 접근제어자 

접근제어자는 우리가 작성한 코드가 다른 파일 또는 모듈에서 접근하는 것을 제한하도록 도와줍니다.

## 접근제어자를 사용할 수 있는 키워드
- Individual types: `class`, `struct`, `enum`
    - Propertios: `let`, `var`
    - Methods
    - Initializers: `designated`, `convinience`
    - Subscripts
- Protocols
- Global constants
- Variables
- Functions

> 다양한 접근제어자를 제공하는데, 스위프트는 일반적인 상황에서 기본 접근 레벨을 제공해줘서 명시적으로 접근 레벨을 명시할 필요를 줄여줍니다.

## 모듈과 소스 파일
접근 제어자를 알아보기 전에, 모듈과 소스 파일을 이해해야 합니다.

### 모듈
모듈은 코드 배포의 단일 유닛입니다.

(ex. 프레임워크나 어플리케이션, `import` 키워드 뒤에 붙는 단어가 모듈입니다.)

프로젝트를 하며 자주 import했던 `Foundation`, `SwifUI`, `UIKit` 등도 모듈입니다.

### 소스 파일
모듈 안에 있는 소스 코드가 적힌 각각의 파일을 의미합니다.

하나의 소스파일에 하나의 Invidiual type을 넣는 경우가 많지만, 한 파일에 복수 개의 type이 들어가도 소스 파일은 1개입니다.

## 제어 레벨
`open` > `public` > `internal` > `fileprivate` > `private`

제어 레벨의 접근성 입니다. `open` 이 제일 개방적이고 `private` 가 제일 폐쇠적입니다.

### Open과 public
두 제어 레벨을 사용한 함수, 프로퍼티는 모두 `import` 를 통해 선언을 한 곳이라면 어느 소스 파일에서든 쓰일 수 있습니다.
보통 프레임워크에 pubilc interface를 정의할 때 사용합니다.
- open: `open`은 오직 클래스와 클래스 멤버들에게만 적용할 수 있습니다. `open`을 사용하면, 외부 모듈에서 상속과 오버라이딩을 할 수 있습니다.

### Internal
`internal`은 어느 소스파일에서든 접근할 수 있지만, 외부 모듈에서는 접근할 수가 없습니다.

`internal`은 Swift 접근 제어자의 기본값입니다. 따라서 접근제어자를 선언하지 않았다면, `internal`로 적용됩니다.

> 유닛 테스트할 때는, 외부 모듈에서 접근하는 것이라 모든 클래스가 `open` 또는 `public`이어야 하지만, `@testable` 어노테이션을 통해 `internal` 클래스라도 외부 모듈에서 접근할 수 있습니다.

### File-private
`fileprivate`는 소스파일 내부에서만 사용할 수 있습니다. 

당연한 말이겠지만, 파일 외부에서 `extension`을 사용하면 에러가 나옵니다.

### private
`private`를 사용하면 그 기능을 정의하고 구현한 범위 안에서 쓸 수 있다.

`fileprivate`와 마찬가지로 파일 외부에서 `extension`을 사용하면 에러가 나옵니다.

## 묵시적 제어 레벨 설정
기본적으로 클래스의 내부의 멤버들에게 접근 지정자를 부여하지 않았을 경우, 해당 클래스의 접근 지정자를 따라 갑니다.

```swift
fileprivate class Car {
    private let serialNumber: String
    fileprivate var fuel: Float
    let payloads: Int // 이 경우 접근 지정자는 fileprivate가 된다.
    
    internal func ride() { }
    public func repair() { }
}
```

> 그러나 클래스를 `public`으로 지정할 경우에는 묵시적 접근지정자는 internal이 된다. 이것을 통해서 실수로 접근 지정자를 지정하지 않더라도, 외부에서 사용하는 일이 없도록 방지해준다.

## 제어 레벨의 가이드 원칙
- 가장 밖의(둘러싼) 접근지정자보다 넓은 지정자를 쓰는 것은 지양해야 합니다.
- 함수는 주변 코드에서 구성 타입을 사용할 수 없는 상황에서 함수를 사용할 수 있기 때문에 파라미터 타입과 반환 타입보다 더 높은 접근 수준을 가질 수 없습니다.

## 튜플, 함수에서의 접근 지정자
- 튜플에서는 튜플 안의 가장 제한적인 접근 지정자가 튜플의 접근 지정자를 결정한다.

```swift
internal struct MyStruct { }
open class MyClass { }

typealias Test = (mS: MyStruct, mC: MyClass)
```

- 함수의 경우에는 파라미터나 리턴 타입의 접근 지정자 중, 가장 제한적인 접근 지정자가 함수의 접근 지정자가 된다.

## 열거형과 중첩 타입에서의 접근 지정자
- 열거형 내부의 케이스는 열거형의 접근 지정자를 따라가기 때문에, 접근 지정자를 쓸 필요가 없습니다.

> **Raw Values and Associated Values**
> 
> 열거형 안에서 Raw Value나 Associated Value를 쓰려면 해당 열거형의 접근 지정자 범위보다 같거나 커야한다.

- 중첩 타입은 그 내부 타입의 접근 접근지정자에 따라 자신의 접근 지정자를 결정합니다.

## 상속
자식 클래스는 부모 클래스의 접근 지정자의 범위보다 클 수 없습니다.
```swift
class A {

}
// 이럴 경우에는 상속이 되지 않습니다.
// internal보다 작거나 같은 범위의 접근 지정자이어야 합니다.
public class B: A {

}
```

오버라이드의 경우에는 부모 클래스의 함수가 어떤 접근 지정자이든 상관없이, 자유롭게 접근 지정자를 선택할 수 있습니다.

## 상수, 변수, 프로퍼티와 서브스크립트
상수, 변수, 프로퍼티는 그것의 타입보다 더 접근 지정자의 범위가 넓을 수 없다.

(`private`타입에 `pubilc`프로퍼티를 넣으면 안된다.)

서브스크립트는 그것의 인덱스 타입과 리턴 타입보다 더 범위가 넓을 수 없다.

### 게터와 세터
게터와 세터는 역시나 그들이 선언된 상수, 변수, 프로퍼티 또는 서브스크립트와 접근 제어자가 같다.

그런데 세터는 특별하게도, 게터보다 더 좁은 접근 지정자를 별도로 부여해줄 수 있다.
`internal(set)`, `private(set)`, `fileprivate(set)`
만약 `private(set)`을 지정했을 경우에는 값에 자유롭게 접근할 수 있다. 그러나 값의 변경은 온전히 클래스(또는 구조체) 내부에서만 이루어질 수 있다.

## 생성자
생성자의 접근 지정자 범위는 이 생성자의 가지고 있는 타입의 접근지정자와 같거나 작아야한다. 그런데 `required init`의 경우에는 반드시 타입과 같은 접근 지정자를 지녀야합니다.

### 기본 생성자
우리가 구조체나 클래스의 프로퍼티에 기본값을 설정했다면, 굳이 생성자를 만들지 않아도 된다. 굳이 생성자를 만들지 않아도 생성자가 있다고 여겨지는 것이 기본 생성자인데, 기본 생성자는 구조체나 클래스의 접근 지정자를 따라갑니다.

그런데 구조체나 클래스의 접근 지정자가 `public`일 경우, 기본 생성자의 접근 지정자는 `internal`이 된다.(생성자를 안만들었을 경우)

### 구조체의 `memberwise`의 기본 생성자
구조체의 모든 저장된 프로퍼티가 private라면 구조체 타입의 기본 멤버별 초기화 구문은 private라고 간주합니다. 마찬가지로 구조체의 모든 저장된 프로퍼티가 file private라면 초기화 구문은 file private 입니다. 그렇지 않으면 초기화 구문은 internal의 접근 수준을 가집니다.

위의 기본 초기화 구문과 마찬가지로 다른 모듈에서 사용될 때 멤버별 초기화 구문으로 초기화 하는 public 구조체 타입은 타입의 정의의 부분으로 public 멤버별 초기화 구문을 자체적으로 제공해야 합니다.

## 프로토콜
프로토콜에 접근 지정자를 쓰고 싶으면, 프로토콜을 선언하는 시점에 접근 지정자를 부여하면 됩니다.
```swift
fileprivate protocol Flyable {
    func foo()
}
```
이렇게 선언된 프로토콜의 내부 함수들의 접근지정자는 마찬가지로 `fileprivate`가 됩니다.
> 프로토콜은 구조체나 클래스와 다르게 `public`으로 선언되면, 내부 함수들도 `public`이 됩니다.

### 프로토콜 상속
프로토콜이 프로토콜을 상속할 경우, 자식 프로토콜은 부모 프로토콜의 접근 제어 범위보다 넓을 수 없습니다.

### 프로토콜 준수
프로토콜과 타입 내 함수의 접근 지정자가 서로 다르다면, 둘 중 더 좁은 범위의 접근 지정자가 당선(?)됩니다.
그리고 `public`타입이 `internal`프로토콜의 함수를 준수해야 할 경우, 작성해야 하는 함수는 적어도 `internal`과 같거나 그것보다 좁아야합니다.